# -*- coding: utf-8 -*-
"""Podstawy_programowania_wyklad_23_24.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uWV8wU_l_cRzgKw4CpItcHNLI5Yl_7Zi

Komentowanie linijek jest omijane przez interpreter - mamy dwie możliwości na dokonywanie komentarzy z jedną linijką i wieloma linijkami. Poniżej przykład:
"""

# Single line comments start with a number symbol.
# zakomentowana linijka nr 2
# kolejny komentarz
# ctrl + / zakomentowanie i odkomentowanie danej linijki

""" Multiline strings can be written
    using three "s, and are often used
    as documentation.
"""

x = 2
print(x)

"""Podstawą w Python są obiekty, które mopgą być typu **int** - liczby całkowite oraz **float** zmiennoprzecinkowe oraz podstawowe operacje na nich.

Dane w pamięci komputera są przechowywane jako ciąg zer oraz jedynek (bitów)
8 bitów tworzy nam jeden bajt przykład ==> 0000 1011 ==> w zapisie binarnym liczba dziesiętna 11. Komputer zapisuje to jako False -> 0 oraz True -> 1

W Python wersja 3 od wersji 3.4 int dostosowuje się do liczby to znaczy dopasowywuje liczbę bajtów potrzebnych do zapisu wartości, ale w wielu systemach zależnie od języka programowania są to wartości stałe w takim sensie że int może zajmować zawsze 4 bajty, albo 8 bajtów itd...

7 to liczba całkowita typu int
0111
0 * 2^3 + 1 * 2^2 + 1 * 2^1 + 1 * 2^0

Wystarczy zapamiętać że zapis float jest o wiele bardziej skomplikowany:

7.0 to liczba typu float

Jak jest zapisywany float. Za pomocą cechy i mantysy i jednego bitu znaku:

ZNAK * mantysa * 2^cecha

dla liczby 9.625 w notacji naukowej systemie 10-tnym 0.9625 * 10^1

**WNIOSEK:**

Przykładem jest liczba 1/3

1/3 = 0.333333333... nie możemy zapisać nieskończoności w pamięci komputera

Jednak w pamięci komputera nie można zapisać tej wartośći w sposób doładny.

Jej zapis zawsze będzie się wiązał z **tzw. błędem numerycznym**
"""

# You have numbers
3  # => 3 - są towartości stałe, czyli poprostu liczby

# Math is what you would expect
1 + 1   # => 2
8 - 1   # => 7
10 * 2  # => 20
35 / 5  # => 7.0 **UWAGA** bo my dzielimy tutaj dwie wartości całkowitoliczbowe.
# Wyżej wykonywaliśmy obliczenia również na takich liczbach, ale cco się okazuje.
# Bo tutaj wynik  jest float, a powyżej był wynik typu int
40 / 5

"""Dzielenie liczb całkowitych (//) zaokrągla w dół zarówno liczby dodatnie, jak i ujemne."""

5 // 3       # => 1 dlatego że 1 całych i 2 reszzty - reszt jest tracona
-5 // 3      # => -2 dlatego że -1 całych i 2 reszty - ze względu na zaokrąglenie w dół uzyskujemy -2
5.0 // 3.0   # => 1.0 # works on floats too - operator dzielenia całkowitoliczbowego działa równineż na liczbach typu float
-5.0 // 3.0  # => -2.0
-5 // 3.0    # => -2.0 wystarczy że jedna liczba dzielna lub dzielnik jest typu float aby wynik również był float
-5.0 // 3    # => -2.0

"""Przyjrzyjmy się zwyczajnemu dzieleniu:"""

# The result of division is always a float
10.0 / 3  # => 3.3333333333333335 - szczególna uwaga to ostatnia wyświetlana cyfra. Dlaczego tak się dzieje? Wartość 5 pojawia się ze względu na błąd numeryczny w zapisie liczb typu float
# porównywanie dwóch liczb typu float nie jest zadaniem trywialnym, gdy mamy wartości bardzo bliskie sobie, np.:
# x = 3.3333333333333335
# y = 3.3333333333333334
# Czy te dwie liczby są sobie równe? Pierwsza nasza odpowiedź brzmi że nie, ale teraz wiedząc że są to wyniki pewnych bardziej złożonych operacji, to pojawia się pytanie ale czy na pewno?
# Być może mamy do czynienia z błęden numerycznym
# tak więc x < y => to Prawda czy Fałsz?
# tak więc x > y => to Prawda czy Fałsz?
# tak więc x == y => to Prawda czy Fałsz?
# Musimy być ostrożni!!! Błędem numerycznym

print(100/3)

# Modulo operation - reszta z dzielenia
7 % 3   # => 1 sieden dzielone na 3 daje nam wynik 2 całe oraz 1 reszta. Operacja modulo zwraca resztę
# i % j have the same sign as j, unlike C
-7 % 3  # => 2 - w skrócie dopełnienie do dzielnika
-11 % 5 # wynik to 2 całe oraz -1 reszty, ale zapisujemy to na plusie w jaki sposób dzielnik -1 reszty = reszte 4

# Exponentiation (x**y, x to the yth power)
2**3  # => 8 --> w innych językach 2 ^ 3, czyli dwa do potęgi trzeciej

# Enforce precedence with parentheses
1 + 3 * 2    # => 7 kolejność operacji zgodna z regułami matematyki, pierw mnożenie a potem dodawanie
(1 + 3) * 2  # => 8 kolejność zgodna z nawiasami

# Boolean values are primitives (Note: the capitalization)
True   # => True zapisujemy z wielkiej litery
False  # => False

# negate with not - not jest opeartorem negacji
not True   # => False
not False  # => True

# Boolean Operators - algebry Boole'a
# Note "and" and "or" are case-sensitive
True and False  # => False --> and tylko dla dwóch wartości True da wartość True a w przeciwnym wypadku da False
False or True   # => True --> or tylko dla dwóch wartości False dostaniemy False w przeciwnym wypadku zawsze jest prawda

# True and False are actually 1 and 0 but with different keywords
True + True # => 2 True jest traktowane jako logiczna jedynka, a False jako logiczne zero
True * 8    # => 8
False - 5   # => -5

# Comparison operators look at the numerical value of True and False
0 == False  # => True porównanie zera i Flase da nam True, zapytanie czy 0 i False są sobie równe
2 > True    # => True
2 == True   # => False
-5 != False # => True != to jest znacznik oznaczający różne czyli pytanie czy -5 oraz Ffalse, czyli zero są różne i odpowiedź brzmi TAK, czyli True

# None, 0, and empty strings/lists/dicts/tuples/sets all evaluate to False.
# All other values are True
bool(0)     # => False Rzutowanie na zmienną logiczną bool()
bool("")    # => False
bool([])    # => False
bool({})    # => False
bool(())    # => False
bool(set()) # => False WNIOSEK: każdy pusta strukturaa danych jest traktowana jako logiczny False
bool(4)     # => True każda liczba dodatnia lub ujemna jest traktowana jako True
bool(-6)    # => True

# Using boolean logical operators on ints casts them to booleans for evaluation,
# but their non-cast value is returned. Don't mix up with bool(ints) and bitwise
# and/or (&,|)
bool(0)     # => False
bool(2)     # => True
0 and 2     # => 0  --> and zwraca nam zero jeżeli jest jednym z argumentów albo tę drugą liczbę
1 and 2     # => 2
3 and -22     # => -22
-11 and 5     # => 5
bool(-5)    # => True
bool(2)     # => True
-5 or 0     # => -5  --> or zwraca nam wartość niebędącą zerem jeżeli są dwa takie argumenty to zwroci tę pierwszą liczbę
5 or 3     # => 5
7 or 33     # => 7

# Equality is ==
1 == 1  # => True operator porównania dwóch liczb
2 == 1  # => False

# Inequality is != operator czy dwie liczby są sobie różne
1 != 1  # => False
2 != 1  # => True

# More comparisons
1 < 10  # => True mniejsze
1 > 10  # => False większe
2 <= 2  # => True mniejsze lub równe UWAGA nie zadziała =< kolejność musi być prawidłowa, czyli: <=
2 >= 2  # => True większe lub równe

# Seeing whether a value is in a range
1 < 2 and 2 < 3  # => True -> True and True
2 < 3 and 3 < 2  # => False -> True and False
# Chaining makes this look nicer skrócony zapis tego co na górze - ttypowe dla Pythona
1 < 2 < 3  # => True
2 < 3 < 2  # => False

# (is vs. ==) is checks if two variables refer to the same object, but == checks
# if the objects pointed to have the same values.
a = [1, 2, 3, 4]  # Point a at a new list, [1, 2, 3, 4] nawais kwadratowy, tworzymy sobie listę
b = a             # Point b at what a is pointing to -> a i b wskazuje na ten sam obiekt na listę ktora jest zapisana w tym samym miejscu pamieci komputera
b is a            # => True, a and b refer to the same object tak a i b odwołuje się do tego samego obiektu
b == a            # => True, a's and b's objects are equal - tutaj porównujemy tylko wartości, ale to te same wartości
b = [1, 2, 3, 4]  # Point b at a new list, [1, 2, 3, 4] - zapisujemy w iinnym mmiejscu pamieci liste [1, 2, 3, 4]
b is a            # => False, a and b do not refer to the same object ze zmienna a i b nie są tym samym obiektem
b == a            # => True, a's and b's objects are equal -  że w dalszym ciągu są to te same wartości

# Strings are created with " or '
"This is a string."
'This is also a string.'
# nie zadziała coś takiego jak: "kot'
# ale to się wyświetli  -> kot'


# Strings can be added too - konkatenacja UWAGA!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  łączenie dwóch ciągów
"Hello " + "world!"  # => "Hello world!" czyli w tym wypadku połączenie dwóch stringów
# String literals (but not variables) can be concatenated without using '+'
"Hello " "world!"    # => "Hello world!" - tylko dla stalych stringów, a nie dla zmiennych mozna dokonac konkatenacji bez znaku plus

# A string can be treated like a list of characters - w tym naawiasie podajemy numer indeksu
"Hello world!"[0]  # => 'H' -> string jest traktowany jako listy
"Hello world!"[1]  # => 'e' -> string jest traktowany jako listy
"Hello world!"[2]  # => 'l' -> string jest traktowany jako listy
"Hello world!"[3]  # => 'l' -> string jest traktowany jako listy
"Hello world!"[4]  # => '0' -> string jest traktowany jako listy
"Hello world!"[5]  # => ' ' -> string jest traktowany jako listy
"Hello world!"[6]  # => 'w' -> string jest traktowany jako listy
"Hello world!"[7]  # => 'o' -> string jest traktowany jako listy


# You can find the length of a string len zwraca długość naszej listy/stringa
len("This is a string")  # => 16

################################################################# ODTĄD ZACZYNAMY KOLEJNY WYKŁAD

# Since Python 3.6, you can use f-strings or formatted string literals.
name = "Reiko"
f"She said her name is {name}." # => "She said her name is Reiko"
# Any valid Python expression inside these braces is returned to the string.
f"{name} is {len(name)} characters long." # => "Reiko is 5 characters long."

# None is an object
None  # => None

# Don't use the equality "==" symbol to compare objects to None
# Use "is" instead. This checks for equality of object identity.
"etc" is None  # => False
None is None   # => True

"""**Wykład nr 2**"""

x = 0.1 + 0.2
print(x)
if x == 0.3:
  print("zmienna x wynosi 0.3")
else:
  print("zmienna x nie wynosi 0.3")

# pętle for
for i  in range(10):# i = 0,1,2...9
  print(i)
print("############################")
for i  in range(4, 10):# i = 4,5,6...9
  print(i)
print("############################")
for i  in range(2, 10,2):# i = 2,4,6,8
  print(i)
print("############################")
for i  in range(10, -2,-2):# i = 10,8,...0
  print(i)
print("############################")
# for i  in range(0, 10, 0.1):# teoretycznie i = 0, 0.1, 0.2 ... 9.8, 9.9  KROK nie może być floatem musi być intem
#   print(i)

lista = [ 2, 3.1, "dom", 'tata', -1, "-1", 2**0.5]
print(lista)
i = 0
for x in lista:
  print(f"Element numer {i} w liscie to: {lista[i]} {x}")
  i += 1

for x in lista:
  print(f"Element w liscie to: {x} i jest on typu {type(x)}")


for i in range(len(lista)):
  print(f"Element numer {i} w liscie to: {lista[i]}")

li = []
for i in range(5):
  li.append(i)
print(li)

print([x**2 for x in li])

a = [i for i in range(10)]
print(a)

# pętla while

li = [i for i in range(10)]
kwadrat = []

i = 0
while i < len(li): # while WARUNEK
  kwadrat.append(li[i]**2)
  i += 1

print(kwadrat)
print([x**2 for x in li])

kwadrat = []
i = 0
while True: # while WARUNEK
  if i<len(li):
    kwadrat.append(li[i]**2)
    i += 1# i = i + 1
  else:
    break

print(kwadrat)

text = "Ola ma kota. Ala ma też."
szyfrogram = []
key = 3

#szyfrowanie
for znak in text:
  tmp = ord(znak)                   # zamiana pojedynczego znaku na wartosc unicode
  tmp = tmp + key                   # przesuniecie o wartosc klucza
  tmp = chr(tmp)                    # zamiaan z powrotem na pojedynczy znak
  szyfrogram.append(tmp)
print(text)
print(szyfrogram)
print(f"Szyfrogram: {''.join(szyfrogram)}")

print(ord('a'), ord("ą"))

for i in range(60):
  znak = chr(ord(".") + i)
  print(f"Dla znaku: {znak} wartość unicode wynosi: {ord(znak)}")

wiadomosc = []
#deszyfrowanie
for znak in szyfrogram:
  tmp = ord(znak)                   # zamiana pojedynczego znaku na wartosc unicode
  tmp = tmp - key                   # przesuniecie o wartosc klucza
  tmp = chr(tmp)                    # zamiaan z powrotem na pojedynczy znak
  wiadomosc.append(tmp)
print(text)
print(wiadomosc)
print(f"Wiadomość jawna: {''.join(wiadomosc)}")

# Funkcje do szyforwania i deszyfrowania szyfru Cezara

def szyfrowanie_szyfr_cezara(tekst_jawny, key):
  szyfrogram = ''
  for znak in tekst_jawny:
    tmp = ord(znak)                   # zamiana pojedynczego znaku na wartosc unicode
    tmp = tmp + key                   # przesuniecie o wartosc klucza
    tmp = chr(tmp)                    # zamiaan z powrotem na pojedynczy znak
    szyfrogram = szyfrogram + tmp
  return szyfrogram

def deszyfrowanie_szyfr_cezara(szyfrogram, key):
  tekst_jawny = ''
  for znak in szyfrogram:
    tmp = ord(znak)                   # zamiana pojedynczego znaku na wartosc unicode
    tmp = tmp - key                   # przesuniecie o wartosc klucza
    tmp = chr(tmp)                    # zamiaan z powrotem na pojedynczy znak
    tekst_jawny = tekst_jawny + tmp
  return tekst_jawny


text = "Ola ma kota. Ala ma też."
klucz = 400
wiadomosc_zaszyfrowana = szyfrowanie_szyfr_cezara(text, klucz)
print(wiadomosc_zaszyfrowana)
wiadomosc_jawna = deszyfrowanie_szyfr_cezara(wiadomosc_zaszyfrowana, klucz)
print(wiadomosc_jawna)
print("########################################")

def sprawdz_alfabet(zdanie, start='A', koniec='z'): #funkcja sprawdzająca czyt wszystkie znaki są w zadanym zakresie alfabetu
  for znak in zdanie:
    if ord(start) > ord(znak) or ord(znak) > ord(koniec):
      return False
  return True


def atak_metoda_brutalna(wiadomosc):
  liczba = 0
  for i in range(1000):
    try:
      tmp = deszyfrowanie_szyfr_cezara(wiadomosc, i)
    except ValueError:
      # print("Wystąpił wyjątek oznacza, że przekroczyliśmy wartości w tablicy Unicode")
      pass
    else:
      liczba += 1
      if sprawdz_alfabet(tmp, ' ', 'ż'):
        print(tmp)
    finally:
      pass
  return liczba


atak_metoda_brutalna(wiadomosc_zaszyfrowana)
# sprawdz_alfabet(text, ' ', 'ż')
atak_metoda_brutalna(szyfrowanie_szyfr_cezara('Tata ma kaca :)', 13))

# def capital_indexes(a):
#     lista = []
#     i = 0
#     for z in a:
#         if 'A'<=z<='Z':
#             lista.append(i)
#         i += 1
#     return lista


def capital_indexes(s):
  upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  return [i for i in range(len(s)) if s[i] in upper]

text = "Ola ma kota. Ala ma też."

capital_indexes(text)


def capital_indexes(a):
    lista = []
    i = 0
    for z in a:
        if z.isupper():
            lista.append(i)
        i += 1
    return lista

a = "TaTa"
capital_indexes(a)


# więcej: https://pythonprinciples.com/challenges/
# https://edabit.com/challenges/python3
# Ciekawe ale nie do konca to co chcemy: https://www.101computing.net/python-turtle-building-a-castle/
# https://www.hackerrank.com/domains/python
# Codewars.com
# https://projecteuler.net/

def fun(n):
  lista = []
  for i in range(n):
    if i%3 == 0:
      lista.append(i)
    elif i%5 == 0:
      lista.append(i)
    else:
      pass
  return sum(lista)

fun(1000)

def fun(n):
  lista = []
  for i in range(n):
    if i%3 == 0:
      lista.append(i)
    if i%5 == 0:
      lista.append(i)
  return sum(lista)

fun(1000)

"""*** 17.12.2023***"""

# wejście to jakaś lista; POdać sumę parzystycch wartości dodatnich
import numpy as np

lista = [1, 2, 3, 4, 5, 6, 7, 8, -10, 10]
macierz = np.array(lista)

suma_elementow = 0
for x in lista:
  if x % 2 == 0 and x > 0:
    suma_elementow += x
print(suma_elementow)

# Porównanie listy i macierzy
# print(lista % 2) #operator modulo nie dziala na listachc
print(macierz % 2) #operator dziala na macierzach
print(macierz[macierz % 2]) # UWAGA !!! parametry podane do macierzy mowia nam o numerach indeksów pomimo że są to wartości logiczne


print(macierz, lista)
print(type(macierz), type(lista))

def oblicz_sume(X):
  '''
  Funkcja obliczająca sumę elementów listy, które są parzyste i dodatnie

  Parametry:
  X (list): Lista liczb (int) podawana jako argument funkcji

  Zwraca:
  int: sumę wszystkich wartości
  '''
  print("Hej, jestem funkcją dla list")
  suma_elementow = 0
  for x in X:
    if x % 2 == 0 and x > 0:
      suma_elementow += x
  return suma_elementow
print(oblicz_sume(lista))

def oblicz_sume(X):
  '''
  Funkcja obliczająca sumę elementów macierzy, które są parzyste i dodatnie

  Parametry:
  X (np.array): Macierz liczb (int) podawana jako argument funkcji

  Zwraca:
  int: sumę wszystkich wartości
  '''
  print("Hej, jestem funkcją dla macierzy")
  suma_elementow = 0
  for x in X:
    if x % 2 == 0 and x > 0:
      suma_elementow += x
  return suma_elementow
oblicz_sume(lista)

#Dwuwymiarowa lista / macierz

x_list = [[1,2],[3,4]]
x_matrix = np.array(x_list)
print(x_list)
print(x_matrix)

print(x_list[1][1])
print(x_matrix[1][1])
print(x_matrix[1,1])

print(np.dot(x_matrix,x_matrix))# mnożenie macierzowe

def mnozenie_macierzowe(m1, m2):
  '''
  Mnożenie dwóch macierzy reprezentowanych w postaci dwwóch list

  Parametry:
  m1 (list): pierwsza macierz
  m2 (list): druga macierz

  Zwraca:
  list: wynik mnożenia dwóch macierzy
  '''
  liczba_wierszy_m1 = len(m1)
  liczba_kolumn_m1 = len(m1[0])
  liczba_wierszy_m2 = len(m2)
  liczba_kolumn_m2 = len(m2[0])

  if liczba_kolumn_m1 != liczba_wierszy_m2:
    raise ValueError("Liczba kolumn m1 oraz wierszy w m2 musi być zgodna (taka sama)")

  result = [[0 for _ in range(liczba_kolumn_m2)] for _ in range(liczba_wierszy_m1)]

  for i in range(liczba_wierszy_m1):
    for j in range(liczba_kolumn_m2):
      for k in range(liczba_kolumn_m1):
        result[i][j] += m1[i][k] * m2[k][j]
  return result

mnozenie_macierzowe(x_list, x_list)
mnozenie_macierzowe(x_matrix, x_matrix)

def funkcja(n):
  '''
  Funkcja tworzy listę dwuwymiarową która jest wymiarowości nxn jest wypełniona samymi zerami a dookoła ma ramkję z 1

  Parametry:
  n (int): wymiarowość kwadratowej listy dwuwymiarowej nxn

  Zwraca:
  list: Wygenerowana lista dwuwymiarowa
  '''

  result = [[0 for _ in range(n)] for _ in range(n)]
  for i in range(n):
    for j in range(n):
      if i == 0 or i == n-1 or j == 0 or j == n-1:
        result[i][j] = 1

  return result

def funkcja1(x, a):
  '''
  Funkcja dodająca nowy wiersz do listy x (list) składający się z wartości a (int/float)

  Parametry:
  x (list): lista do modyfikacji
  a (int/float): wartość w nowym wierszu

  Zwraca:
  None: nic nie zwraca ale modyfikuje dwuwymiarowa liste wejsciowa
  '''
  nowy_wiersz = [a] * len(x[0])
  a += 1
  # print(nowy_wiersz)
  # x.append(nowy_wiersz)
  # print(x)
  return x.append(nowy_wiersz)

par = 10
d = funkcja(5)
print(np.array(d))
print((funkcja1(d, par)))
print(np.array(d))
print(par)

# [1] * 20
# np.array([1]) * 20

def funkcja2(x, a):
  '''
  Funkcja dodająca nowy wiersz do listy x (list) składający się z wartości a (int/float)

  Parametry:
  x (list): lista do modyfikacji
  a (int/float): wartość w nowym wierszu

  Zwraca:
  list: lista z nowym wierszem
  '''
  nowy_wiersz = [a] * len(x[0])
  tmp = x.copy()
  tmp.append(nowy_wiersz)
  return tmp

p = funkcja(3)
funkcja2(p, 13)
print(p)

def funkcja3(x,a):
  '''
  Funkcja dodająaca nową kolumnę do listy x (list) składającą się z wartości a (int/float)

  Parametry:
  x (list): lista do modyfikacji
  a (int/float): wartość w nowym wierszu

  Zwraca:
  list: lista z nowym wierszem
  '''
  tmp = x.copy()
  for row in tmp:
    row.append(a)
  return tmp

p = funkcja(3)
np.array(funkcja3(p, 13))

def funkcja4(x,a):
  '''
  Funkcja dodająca nową kolumnę do listy x (list) składającą się z wartości a (int/float) - jako pierwszą kolumnę

  Parametry:
  x (list): lista do modyfikacji
  a (int/float): wartość w nowym wierszu

  Zwraca:
  list: lista z nowym wierszem
  '''
  tmp = x.copy()
  for row in tmp:
    row.insert(0, a)
  return tmp

p = funkcja(3)
np.array(funkcja2(funkcja3(funkcja4(p, 13),13),13))

print([1] * 5) # lista
print(np.array([1]) * 5) # macierz

lista1 = [1,2,3]
lista2 = [4,5,6]
print(lista1 + lista2) # + oznacza tutaj operację konkatenacji dwóch list
print(np.array(lista1) + np.array(lista2))

suma_dwoch_list = [x+y for x, y in zip(lista1, lista2)]

def fun(n):
  '''
  Funkcja tworzy listę dwuwymiarową która jest wymiarowości nxn jest wypełniona samymi zerami a na obu przekątnych mamy wartość 1

  Parametry:
  n (int): wymiarowość kwadratowej listy dwuwymiarowej nxn

  Zwraca:
  list: Wygenerowana lista dwuwymiarowa
  '''
  # dla n<=0  raise()
  # n powinno dzialac tylko dla int raise
  if not isinstance(n, int) or n <= 0:
    raise ValueError("Wartość n musi być dodatnim int'em")

  result = [[0 for _ in range(n)] for _ in range(n)]

  for i in range(n):
    result[i][i] = 1
    result[i][n-1-i] = 1

  return result

fun(18)

"""2024-01-13 13:30-18:40 Wykład - powtórka do Egzaminu (przykładowe pytania itp itd)"""