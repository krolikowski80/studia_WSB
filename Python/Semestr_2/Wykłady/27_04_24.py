# # -*- coding: utf-8 -*-
# """Untitled32.ipynb

# Automatically generated by Colab.

# Original file is located at
#     https://colab.research.google.com/drive/1Ou8lQ-a-ihC3b5-P2QsdhPe5vTEB0xBH
# """

# # Liczba interwałowa [a,b]: x | a <= x <= b; a <= b
# x = [5,10]
# y = [7,12]
# print(x,y)

# def srednia(x1,x2):
#   tmp1 = (x1[0]+x2[0])/2
#   tmp2 = (x1[1]+x2[1])/2
#   return [tmp1, tmp2]

# def dodaj(x1,x2):
#   tmp1 = (x1[0]+x2[0])
#   tmp2 = (x1[1]+x2[1])
#   return [tmp1, tmp2]

# def wyswietl(z):
#   print(f"Liczba intrwałowa {z}, gdzie lewy kraniec to {z[0]}, a prawy to {z[1]}")

# z = srednia(x,y)
# print(z)
# z = dodaj(x,y)
# print(z)
# wyswietl(z)

# type(z)

# class LiczbaInterwalowa:
#   """
#   Reprezentacja liczby interwałowej [a, b], gdzie a <= x <= b, czyli również a <= b

#   Atrybuty:
#     a (float): lewy kraniec interwału
#     b (float): prawy kraniec interwału
#   """

#   def __init__(self, a, b):
#     """
#     Konstruktor inicjalizujacy nową instację liczby interwałowej.

#     Parametry:
#       a (float): lewy kraniec interwału
#       b (float): prawy kraniec interwału
#     """
#     if a > b:
#       raise ValueError("Lewy kraniec musi być mniejszy lub równy prawemu.")
#     self.a = a
#     self.b = b

#   def __str__(self):
#     """
#     Zwraca reprezentację liczby interwałowej w sposób łatwy do odczytania
#     """
#     return f"Liczba interwałowa [{self.a}, {self.b}]"

#   def __repr__(self):
#     """
#     Zwraca reprezentację techniczną liczby interwałowej w sposób łatwy do odczytania dla PROGRAMISTY
#     """
#     return f"LiczbaInterwalowa({self.a},{self.b})"

#   def __add__(self, tmp):
#     """
#     Dodaje dwie liczby interwałowe.

#     Parametry:
#       tmp (LiczbaInterwalowa | int | float): Druga liczba interwałowa.

#     Zwraca:
#       LiczbaInterwalowa: Nowy obiekt będący sumą dwóch liczb interwałowych
#     """
#     if isinstance(tmp, LiczbaInterwalowa):
#       new_a = self.a + tmp.a
#       new_b = self.b + tmp.b
#     elif isinstance(tmp, (int, float)):
#       new_a = self.a + tmp
#       new_b = self.b + tmp
#     else:
#       raise ValueError("Obiekt musi być typu LiczbaInterwalowa, int lub float")
#     return LiczbaInterwalowa(new_a, new_b)

#   def __radd__(self, tmp):
#     """
#     Zapewnia przemienność dodawania.
#     """
#     return self.__add__(tmp)

#   def __sub__(self, tmp):
#     """
#     Odejmuje dwie liczby interwałowe.

#     Parametry:
#       tmp (LiczbaInterwalowa | int | float ): Druga liczba odejmowana od pierwszej.

#     Zwraca:
#       LiczbaInterwalowa: Nowy obiekt będący różnicą dwóch liczb interwałowych
#     """
#     # [a,b] -[c,d] = [a-d, b-c]
#     # [2,10] - [5,10] = [-8, 5]
#     if isinstance(tmp, LiczbaInterwalowa):
#       new_a = self.a - tmp.b
#       new_b = self.b - tmp.a
#     elif isinstance(tmp, (int, float)):
#       new_a = self.a - tmp
#       new_b = self.b - tmp
#     else:
#       raise ValueError("Obiekt musi być typu LiczbaInterwalowa, int lub float")
#     return LiczbaInterwalowa(new_a, new_b)

#   def __rsub__(self, tmp):
#     """
#     Zapewnia, że odejmowanie jest możliwe, gdy liczba interwałowa występuje po prawej stronie znaku -
#     """
#     if isinstance(tmp, (int, float)):
#       new_a = tmp - self.b
#       new_b = tmp - self.a
#       return LiczbaInterwalowa(new_a, new_b)
#     else:
#       raise ValueError("Obiekt musi być typu LiczbaInterwalowa, int lub float")
#   def __mul__(self, tmp):
#     """
#     Mnożenie liczby interwałowej przez inną liczbę

#     Parametry:
#       tmp (LiczbaInterwalowa | int | float): mnożnik (druga wartość przy mnożeniu)

#     Zwraca:
#       LiczbaInterwalowa: Nowy obiekt będący iloczynem mnożnej oraz mnożnika
#     """
#     if isinstance(tmp, LiczbaInterwalowa):
#       results = [self.a*tmp.a, self.a*tmp.b, self.b*tmp.a, self.b*tmp.b]
#       new_a = min(results)
#       new_b = max(results)
#     elif isinstance(tmp, (int, float)):
#       new_a = new_a * tmp
#       new_b = new_b * tmp
#       if tmp < 0:
#         new_a, new_b = new_b, new_a
#     else:
#       raise ValueError("Obiekt musi być typu LiczbaInterwalowa, int lub float")
#     return LiczbaInterwalowa(new_a, new_b)

#   def __neg__(self):
#     """
#     Zmienia liczbę na liczbę przeciwną.

#     Zwraca:
#       LiczbaInterwalowa: Nowy obiekt będący liczbą przeciwną.
#     """
#     return LiczbaInterwalowa(-self.b, -self.a)
#   def len(self):
#     """
#     Oblicza dlugosc naszego interwału.

#     Zwraca:
#       float: Długość naszego interwału.
#     """
#     return self.b - self.a


# x = LiczbaInterwalowa(5,10)

# print(type(x))
# print(x)# rzutowanian naszej zmiennej x na stringa i to uruchamia naszą funkcję __str__
# print(repr(x))
# print((-x)*(x))
# print(x, "długość", x.len())


# help(LiczbaInterwalowa)

# def dodaj(a):
#   return a+2



# def dodaj(a):
#   if isinstance(a,int):
#     return a+2
#   if isinstance(a,float):
#     return a+102
#   else:
#     raise ValueError("Obiekt musi być typu int lub float")



# dodaj(int(float("2.0")))

# # class Konto2:
# #   def __init__(self):
# #     self.saldo = 0

# class Konto:
#   def __init__(self):
#     self.__saldo = 0 # podwójne podkreślenie z lewej strony oznacza że zmienna jest prywatna
#     self._pole_chronione = "To jest pole chronione"
#   def wplacaj(self, kwota):
#     if kwota>0:
#       self.__saldo += kwota
#       print(f"Wpłacono na konto: {kwota}\nAktualny stan konta wynosi {self.__saldo}")
#     else:
#       print(f"Kwota wpłąty musi być większa od 0. Podano kwotę {kwota}.")
#   def __metoda_nie_wiem(self):
#     print("Nie mam pomysłu")

#   def wyplacaj(self, kwota):
#     if 0 <= kwota <= self.__saldo:
#       self.__saldo -= kwota
#       print(f"Wyplacono kwotę {kwota}\nAktualny stan konta to: {self.__saldo}")
#     else:
#       print(f"Niewystarczające środki lub nieprawidłowa kwota.")

#   def saldo2(self):
#     return self.__saldo
#   @property
#   def saldo(self):
#     return self.__saldo

#   @saldo.setter
#   def nowe_saldo(self, nowe):
#     if nowe< 0:
#       print("saldo nie może być niższe od zera")
#     else:
#       self.__saldo = nowe
#       print(f"Nowe saldo wynosi: {self.__saldo}")

# class KlasaPochodna(Konto):
#   def __init__(self):
#     super().__init__()

# C = KlasaPochodna()
# print(C._Konto__metoda_nie_wiem())


# # A = Konto2()
# B = Konto()
# B.nowe_saldo = 250
# print(B.nowe_saldo)
# print(B.saldo2())
# print(B.saldo)
# print(B._Konto__saldo)# zła praktyka!!!! Tak nie powinno się robić!!!
# B._Konto__metoda_nie_wiem()
# # print(A.saldo)
# print(B._pole_chronione)
# B.wplacaj(100)
# B.wplacaj(100)
# B.wyplacaj(-100)

# #DZIEDZICZENIE


# class Samochod: #klasa bazowa
#   def __init__(self, marka, model):
#     self.marka = marka
#     self.model = model

#   def disp(self):
#     print(f"Marka: {self.marka}, Model: {self.model}")


# class Osobowy(Samochod): #klasa pochodna
#   def __init__(self, marka, model, liczba_drzwi):
#     super().__init__(marka, model)
#     self.liczba_drzwi = liczba_drzwi

#   def info(self):
#     self.disp()
#     print(f"Liczba drzwi: {self.liczba_drzwi}")

# class Zatopiony(Samochod):
#   def __init__(self,marka,model, czy_zatopiony):
#     super().__init__(marka,model)
#     self.czy_zatopiony = czy_zatopiony

#   def pokaz_status(self):
#     if self.czy_zatopiony == True:
#       print(f"Samochód został zatopiony 16.04.2024")
#     else:
#       print(f"Samochód nie został zatopiony 16.04.2024")



# class ZatopionaOsobowka(Osobowy, Zatopiony):
#   def __init__(self, marka, model, liczba_drzwi, czy_zatopiony):
#     Samochod.__init__(self, marka, model)
#     self.liczba_drzwi = liczba_drzwi
#     self.czy_zatopiony = czy_zatopiony

#   def pokaz(self):
#     self.info()
#     self.pokaz_status()


# auto1 = Samochod("Toyota", "Corolla")
# print("#################")
# auto2 = Osobowy("Toyota", "Corolla",4)
# auto1.disp()
# print("#################")
# auto2.info()
# print("#################")
# auto2.disp()
# print("#################")

# auto3 = ZatopionaOsobowka("Toyota", "Corolla", 4, True)
# auto3.pokaz()

# auto4 = ZatopionaOsobowka("Toyota", "Yaris", 3, False)
# auto4.pokaz()

from abc import ABC, abstractmethod
import math

class Figura(ABC):
    @abstractmethod
    def pole(self):
        pass

    @abstractmethod
    def obwod(self):
        pass

    def info(self):
        print("To jest figura geometryczna.")

class Kwadrat(Figura):
    def __init__(self, bok):
        self.bok = bok

    def pole(self):
        return self.bok ** 2

    def obwod(self):
        return self.bok * 4

    def info(self):
        super().info()
        print(f"Ta figura to Kwadrat. Pole = {self.pole()} a Obwód to: {self.obwod()}")

class Prostokat(Figura):
    def __init__(self, dlugosc, szerokosc):
        self.dlugosc = dlugosc
        self.szerokosc = szerokosc

    def pole(self):
        return self.dlugosc * self.szerokosc

    def obwod(self):
        return 2 * (self.dlugosc + self.szerokosc)

    def info(self):
        super().info()
        print(f"Ta figura to Prostokąt. Pole = {self.pole()} a Obwód to: {self.obwod()}")

class Kolo(Figura):
    def __init__(self, promien):
        self.promien = promien

    def pole(self):
        return math.pi * (self.promien ** 2)

    def obwod(self):
        return 2 * math.pi * self.promien

    def info(self):
        super().info()
        print(f"Ta figura to Koło. Pole = {self.pole()} a Obwód to: {self.obwod()}")

# Testowanie klas
moja_figura = Kwadrat(5)
moja_figura.info()

prostokat = Prostokat(3, 7)
prostokat.info()

kolo = Kolo(4)
kolo.info()
